Directional

Localizing priority, weight of nodes or edges
Integrating nameable Plane objects... essentially 3D versions of 2D Edges. 

UI considerations - VR vs Desktop primacy

Peace between explicit (user-added) Edges and systemically generated edges ( CompleteGraphBetween )


Log

Refactored 

- Changed "edgesFromNodeToAllNodes()" to "connectNodeToNodeArray()". The refactored function now takes an array of nodes as its third param. This makes the function potentially
  far more useful in being able to generate complete graphs within an array of nodes as before, but also to handle situations such as connecting master nodes to set of subnodes, 
  as in a mindmap or other branching or structure. 
  
- Added _Math.possibleEdges() function to support LucidNodes in calculating whether a graph is complete.
  
  
What's hard to change? How to make it easy to change?
  - Explicit vs Programmatic Graph genesis (Edges, Nodes, Graphs)
	  - Develop a method for handling the fork between these. Fully understand the difference that would be required in 
			- Functionality
			- UX transition. 
			- What functions would serve both possibilities?
			- Handling some behavior in UX/UI vs via hardcode? Ie, the user creates the 'system,' 'completes the graph' and can set up desired behaviors in UI/Front-end. 
			
  - How to have multiple 'graphs' in a single file, while the file itself is treated as a single graph
		- Potential solution built into version 1.9.5 - It's now possible to pass an array of nodes and check if it's a complete graph. Dynamic checking makes it possible
		  to have complete graphs be created/destroyed by the user inside a system of nodes, and, if verified complete as graphs, be treated uniquely. This also portends the
		  possibility of other graph types, such as incomplete, but closed, or branching/tree structures to be detected automatically and treated uniquely when detected.
		- Some refactoring suggested for the new potential solution mentioned. 
			- An array.clean() function that handles the work of 
				- removing duplicate entries
				- deleting references to graphElements identical to the graphElement being checked as the origin point
				- deleting references to non-existent graphElements.
			- Removing duplicate instrumentation arising out of nested function calls.
		- Make functions able to recieve either an array of Nodes or an array of ids. For this to work, add a "referent" property to the graphElement "id" property.
		- Detect loose nodes using a nodeHasEdges() function that simply tests for edges and returns true or false.  
		  
  - UI should be highly flexible. The set of tools may change significantly. The UI interface will change wildly both to accomodate desktop vs AR situations. AR situation itself 
    will involve a lot of experimentation. We'll want to iterate quickly. 
	
  - Make graph completion functions explicit (executed via UI tools) rather than implicit as first step toward preserving functionality while creating user control. 
		-Functions executed: 
				- graphFromJson
				- renderGraph
				- nodesFromJson
				- completeGraphFromNodes( graph ); - ACTIONS: refactor this function to take any array of nodes. DONE Test using the UI element. DONE Activate multiselect capability. Pass the selected as an array to the function. Test. Work out error conditions. DONE Replicate for the other functions on this list. 
				- LUCIDNODES.showGraphCenterPoints( graph );
				- getNodeEdges({ graph: graph, node: graph.nodes[i] });
				- getNodesAdjacentToNode( graph.nodes[i] );
		  
isComplete = function( nodeArray ){

	var possEdges = _Math.possibleEdges( nodeArray.length );

};

countEdgesInGraph = function( nodeArray ){

	var edgeCount = 0;

	for ( n = 0, n < nodeArray.length, n++ ){ // For every node in the node array
		
		for ( e = 0, e < nodeArray[n].edges.length, e++ ){  // Retrieve and iterate through all the edges associated with that node.
		
			// and determine if that edge's id also includes the id of any of the other nodes.
			// If it does, add it to the count;
		
		
		
		}
	
	}
};


Deep bug in SELECTED:

Multiselect: 
	- CTRL-Click (First Time): 3 Nodes successfully selected (transformed) and added to SELECTED ARRAY.
	- Click outside after Multiselection above: All nodes unselected (undransformed) and removed from SELECTED ARRAY
	- Click of node (after purge): Correct node selected (transformed) and added to SELECTED array.
	- Click outside node after single select: Node unselected (untransformed) and removed from SELECTED array.
	- CTRL-Click (after purge): 3 Nodes successfully selected (transformed) and added to SELECTED array.
	- CTRL-Click selected nodes, no change to SELECTED array. (That's good).
	- Click FIRST selected node after multi-select of 3 Nodes: FIRST Selected node is in the array twice. Third node remains selected (transformed), in array. Second is unseleected and removed from array.
	- Click outside afterward, all nodes unselected and removed from array.
	- Click THIRD selected Node, THIRD remains selected, is duplicated, SECOND remains selected, first is unselected
	